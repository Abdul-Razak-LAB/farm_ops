{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\n\r\nexport async function middleware(request: NextRequest) {\r\n  const response = NextResponse.next();\r\n\r\n  // 1. Security Headers\r\n  response.headers.set('X-Content-Type-Options', 'nosniff');\r\n  response.headers.set('X-Frame-Options', 'DENY');\r\n  response.headers.set('X-XSS-Protection', '1; mode=block');\r\n  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');\r\n  response.headers.set(\r\n    'Content-Security-Policy',\r\n    \"default-src 'self'; script-src 'self'; object-src 'none';\"\r\n  );\r\n\r\n  // 2. Auth Check (Simplistic version for brevity)\r\n  // In production, use session token validation against DB/Redis\r\n  const sessionToken = request.cookies.get('session_token')?.value;\r\n  const isAuthRoute = request.nextUrl.pathname.startsWith('/api/auth');\r\n  const isPublicRoute = request.nextUrl.pathname === '/';\r\n  const isStateChanging = ['POST', 'PUT', 'PATCH', 'DELETE'].includes(request.method);\r\n\r\n  if (!sessionToken && !isAuthRoute && !isPublicRoute && request.nextUrl.pathname.startsWith('/api')) {\r\n    return Response.json(\r\n      { success: false, error: { code: 'UNAUTHORIZED', message: 'Auth required' } },\r\n      { status: 401 }\r\n    );\r\n  }\r\n\r\n  if (isStateChanging && request.nextUrl.pathname.startsWith('/api')) {\r\n    const origin = request.headers.get('origin');\r\n    const host = request.headers.get('host');\r\n    if (origin && host) {\r\n      const originHost = new URL(origin).host;\r\n      if (originHost !== host) {\r\n        return Response.json(\r\n          { success: false, error: { code: 'FORBIDDEN_ORIGIN', message: 'Invalid request origin' } },\r\n          { status: 403 }\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return response;\r\n}\r\n\r\nexport const config = {\r\n  matcher: ['/api/:path*'],\r\n};\r\n"],"names":["middleware","request","response","next","headers","set","sessionToken","cookies","get","value","isAuthRoute","nextUrl","pathname","startsWith","isPublicRoute","isStateChanging","includes","method","Response","json","success","error","code","message","status","origin","host","originHost","URL","config","matcher"],"mappings":";;;;;;AAAA;AAAA;;AAEO,eAAeA,WAAWC,OAAoB;IACnD,MAAMC,WAAW,gMAAY,CAACC,IAAI;IAElC,sBAAsB;IACtBD,SAASE,OAAO,CAACC,GAAG,CAAC,0BAA0B;IAC/CH,SAASE,OAAO,CAACC,GAAG,CAAC,mBAAmB;IACxCH,SAASE,OAAO,CAACC,GAAG,CAAC,oBAAoB;IACzCH,SAASE,OAAO,CAACC,GAAG,CAAC,mBAAmB;IACxCH,SAASE,OAAO,CAACC,GAAG,CAClB,2BACA;IAGF,iDAAiD;IACjD,+DAA+D;IAC/D,MAAMC,eAAeL,QAAQM,OAAO,CAACC,GAAG,CAAC,kBAAkBC;IAC3D,MAAMC,cAAcT,QAAQU,OAAO,CAACC,QAAQ,CAACC,UAAU,CAAC;IACxD,MAAMC,gBAAgBb,QAAQU,OAAO,CAACC,QAAQ,KAAK;IACnD,MAAMG,kBAAkB;QAAC;QAAQ;QAAO;QAAS;KAAS,CAACC,QAAQ,CAACf,QAAQgB,MAAM;IAElF,IAAI,CAACX,gBAAgB,CAACI,eAAe,CAACI,iBAAiBb,QAAQU,OAAO,CAACC,QAAQ,CAACC,UAAU,CAAC,SAAS;QAClG,OAAOK,SAASC,IAAI,CAClB;YAAEC,SAAS;YAAOC,OAAO;gBAAEC,MAAM;gBAAgBC,SAAS;YAAgB;QAAE,GAC5E;YAAEC,QAAQ;QAAI;IAElB;IAEA,IAAIT,mBAAmBd,QAAQU,OAAO,CAACC,QAAQ,CAACC,UAAU,CAAC,SAAS;QAClE,MAAMY,SAASxB,QAAQG,OAAO,CAACI,GAAG,CAAC;QACnC,MAAMkB,OAAOzB,QAAQG,OAAO,CAACI,GAAG,CAAC;QACjC,IAAIiB,UAAUC,MAAM;YAClB,MAAMC,aAAa,IAAIC,IAAIH,QAAQC,IAAI;YACvC,IAAIC,eAAeD,MAAM;gBACvB,OAAOR,SAASC,IAAI,CAClB;oBAAEC,SAAS;oBAAOC,OAAO;wBAAEC,MAAM;wBAAoBC,SAAS;oBAAyB;gBAAE,GACzF;oBAAEC,QAAQ;gBAAI;YAElB;QACF;IACF;IAEA,OAAOtB;AACT;AAEO,MAAM2B,SAAS;IACpBC,SAAS;QAAC;KAAc;AAC1B"}}]
}